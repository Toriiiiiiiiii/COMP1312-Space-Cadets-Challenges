from bbc import parser


class CompilerScope:
    def __init__(self, parent=None):
        self.parent = parent
        self.vars = {}


class Compiler:
    def __init__(self, node: parser.ASTNode):
        self.node = node
        self.funcs = {}
        self.globalScope = CompilerScope()
        self.asmCode = ""


class CompFunction:
    def __init__(self, name: str, ret: str, params: list, body: parser.ASTNode):
        self.name = name
        self.ret = ret
        self.params = params
        self.body = body


def getVariable(name: str, scope: CompilerScope):
    for var in scope.vars:
        if var == name:
            return scope.vars[name]

    if scope.parent:
        return getVariable(name, scope.parent)

    return None


def compileNode(comp: Compiler, node: parser.ASTNode, scope: CompilerScope):
    if node.nodeType == "DEFUN":
        [name, ret] = node.val.split(":")
        comp.funcs[name] = (ret, node.children[0], node.children[1])

    elif node.nodeType == "CODE":
        for ch in node.children:
            compileNode(comp, ch, scope)

    elif node.nodeType == "INT":
        comp.asmCode += f"\tmov rax, {str(node.val)}\n"
        comp.asmCode += "\tcall __stk_push\n"

    elif node.nodeType == "OPER":
        for ch in node.children:
            compileNode(comp, ch, scope)

        match node.val:
            case "+":
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tmov rdi, rax\n"
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tadd rax, rdi\n"
                comp.asmCode += "\tcall __stk_push\n"
            case "-":
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tmov rdi, rax\n"
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tsub rax, rdi\n"
                comp.asmCode += "\tcall __stk_push\n"
            case "*":
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tmov rdi, rax\n"
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\timul rax, rdi\n"
                comp.asmCode += "\tcall __stk_push\n"
            case "/":
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tmov rdi, rax\n"
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tmov rdx, 0\n"
                comp.asmCode += "\tdiv rdi\n"
                comp.asmCode += "\tcall __stk_push\n"
            case "%":
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tmov rdi, rax\n"
                comp.asmCode += "\tcall __stk_pop\n"
                comp.asmCode += "\tmov rdx, 0\n"
                comp.asmCode += "\tdiv rdi\n"
                comp.asmCode += "\tmov rax, rdx\n"
                comp.asmCode += "\tcall __stk_push\n"


    elif node.nodeType == "RETURN":
        compileNode(comp, node.children[0], scope)
        comp.asmCode += "\tleave\n"
        comp.asmCode += "\tret\n"

    elif node.nodeType == "KEYWORD":
        if getVariable(node.val, scope):
            comp.asmCode += f"\tmov rax, {getVariable(node.val, scope)[1]}\n"
            comp.asmCode += "\tcall __stk_push\n"
        else:
            # TODO: Improve error
            print("Var not found.")
            exit(1)

    elif node.nodeType == "FNCALL":
        if node.val not in comp.funcs:
            print(f"{node.file}:{node.line}:{node.col}: Undefined reference to function {node.val}.")
            exit(1)

        if len(node.children) != len(comp.funcs[node.val][1].children):
            print(f"{node.file}:{node.line}:{node.col}: Incorrect number of arguments for {node.val}.")
            exit(1)

        for ch in node.children:
            compileNode(comp, ch, scope)

        comp.asmCode += f"\tcall {node.val}\n"

    return None


def getProgramHeader(comp: Compiler):
    comp.asmCode += ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
    comp.asmCode += "; NSBB Autogenerated Assembly                     ;\n"
    comp.asmCode += "; Generated by the PYTHON implementation of NSBB. ;\n"
    comp.asmCode += ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n"
    comp.asmCode += "section .text\n"
    comp.asmCode += "extern printf\n"
    comp.asmCode += "extern _exit\n"
    comp.asmCode += "global main\n"


def getProgramFooter(comp: Compiler):
    comp.asmCode += "__stk_push:\n"
    comp.asmCode += "\tenter 0, 0\n"
    comp.asmCode += "\tpush rax\n\tpush rdi\n"
    comp.asmCode += "\tmov rdi, [__stk_ptr]\n"
    comp.asmCode += "\tmov [__stk+rdi], rax\n"
    comp.asmCode += "\tadd rdi, 8\n"
    comp.asmCode += "\tmov [__stk_ptr], rdi\n"
    comp.asmCode += "\tpop rdi\n\tpop rax\n"
    comp.asmCode += "\tleave\n"
    comp.asmCode += "\tret\n\n"

    comp.asmCode += "__stk_pop:\n"
    comp.asmCode += "\tenter 0, 0\n"
    comp.asmCode += "\tpush rdi\n"
    comp.asmCode += "\tmov rdi, [__stk_ptr]\n"
    comp.asmCode += "\tsub rdi, 8\n"
    comp.asmCode += "\tmov rax, [__stk+rdi]\n"
    comp.asmCode += "\tmov [__stk_ptr], rdi\n"
    comp.asmCode += "\tpop rdi\n"
    comp.asmCode += "\tleave\n"
    comp.asmCode += "\tret\n\n"

    comp.asmCode += "__stk_peek:\n"
    comp.asmCode += "\tenter 0, 0\n"
    comp.asmCode += "\tmov rax, [__stk+rdi*8]\n"
    comp.asmCode += "\tleave\n"
    comp.asmCode += "\tret\n\n"

    comp.asmCode += "section .data\n"
    comp.asmCode += "__stk_ptr: dq 0\n"

    comp.asmCode += "section .bss\n"
    comp.asmCode += "__stk: resq 2048\n"


def compCompile(comp: Compiler) -> str:
    getProgramHeader(comp)
    for node in comp.node.children:
        compileNode(comp, node, comp.globalScope)

    for fn in comp.funcs:
        retType, params, body = comp.funcs[fn]
        nBytes = 8 * len(params.children)
        comp.asmCode += f"{fn}:\n"
        comp.asmCode += f"\tenter {nBytes}, 0\n"

        scope = CompilerScope(comp.globalScope)
        rspOffset = 0
        for param in params.children:
            [pType, pName] = param.val.split(":")
            scope.vars[pName] = (pType, f"[rsp+{rspOffset}]")

            comp.asmCode += "\tcall __stk_pop\n"
            comp.asmCode += f"\tmov [rsp+{rspOffset}], rax\n"

            rspOffset += 8

        compileNode(comp, body, scope)

        comp.asmCode += "\n"
        comp.asmCode += "\t; Fallthrough in case function doesn't use RETURN.\n"
        comp.asmCode += "\tleave\n"
        comp.asmCode += "\tret\n\n"

    getProgramFooter(comp)
    return comp.asmCode
